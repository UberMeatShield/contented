package actions

import (
    "log"
    "net/http"
    // "errors"
    // "fmt"
    "contented/managers"
    "contented/models"
    "github.com/gobuffalo/buffalo"
    // "github.com/gobuffalo/pop/v5"
    "github.com/gobuffalo/x/responder"
    "github.com/gofrs/uuid"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Content)
// DB Table: Plural (contents)
// Resource: Plural (Contents)
// Path: Plural (/contents)
// View Template Folder: Plural (/templates/contents/)

// ContentsResource is the resource for the Content model
type ContentsResource struct {
    buffalo.Resource
}

// List gets all Contents. This function is mapped to the path
// GET /contents
func (v ContentsResource) List(c buffalo.Context) error {
    // Get the DB connection from the context

    man := managers.GetManager(&c)
    var contentContainers *models.Contents

    // Optional params suuuuck in GoLang
    cID_str := c.Param("container_id")
    if cID_str != "" {
        log.Printf("Attempting to get content using %s", cID_str)
        cID, err := uuid.FromString(cID_str)
        if err != nil {
            return c.Error(http.StatusBadRequest, err)
        }
        mcs, q_err := man.ListContentContext(cID)
        if q_err != nil {
            return c.Error(http.StatusBadRequest, err)
        }
        contentContainers = mcs
    } else {
        log.Printf("List all Content No Restriction on the container ID")
        // TODO: Fix the lack of page support and TEST IT
        _, per_page, page := managers.GetPagination(c.Params(), man.GetCfg().Limit)
        mcs, err := man.ListAllContent(page, per_page)
        if err != nil {
            return c.Error(http.StatusBadRequest, err)
        }
        contentContainers = mcs
    }
    return responder.Wants("html", func(c buffalo.Context) error {
        return c.Render(200, r.JSON(contentContainers))
    }).Wants("json", func(c buffalo.Context) error {
        return c.Render(200, r.JSON(contentContainers))
    }).Wants("xml", func(c buffalo.Context) error {
        return c.Render(200, r.XML(contentContainers))
    }).Respond(c)
}

// Show gets the data for one Content. This function is mapped to
// the path GET /contents/{content_id}
func (v ContentsResource) Show(c buffalo.Context) error {
    man := managers.GetManager(&c)

    // TODO: Make it actually just handle /content (page, number)
    uuid, err := uuid.FromString(c.Param("content_id"))
    if err != nil {
        return c.Error(http.StatusBadRequest, err)
    }

    contentContainer, missing_err := man.GetContent(uuid)
    if missing_err != nil {
        return c.Error(http.StatusNotFound, missing_err)
    }

    return responder.Wants("html", func(c buffalo.Context) error {
        return c.Render(200, r.JSON(contentContainer))
    }).Wants("json", func(c buffalo.Context) error {
        return c.Render(200, r.JSON(contentContainer))
    }).Wants("xml", func(c buffalo.Context) error {
        return c.Render(200, r.XML(contentContainer))
    }).Respond(c)
}

// Create adds a Content to the DB. This function is mapped to the
// path POST /contents
func (v ContentsResource) Create(c buffalo.Context) error {
    _, tx, err := managers.ManagerCanCUD(&c)
    if err != nil {
        return err
    }
    // Allocate an empty Content
    // Bind contentContainer to the html form elements (probably not required?)
    contentContainer := &models.Content{}
    if err := c.Bind(contentContainer); err != nil {
        return err
    }

    // Validate the data from the html form
    verrs, err := tx.ValidateAndCreate(contentContainer)
    if err != nil {
        return err
    }

    if verrs.HasAny() {
        return responder.Wants("html", func(c buffalo.Context) error {
            return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
        }).Wants("json", func(c buffalo.Context) error {
            return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
        }).Wants("xml", func(c buffalo.Context) error {
            return c.Render(http.StatusUnprocessableEntity, r.XML(verrs))
        }).Respond(c)
    }

    return responder.Wants("html", func(c buffalo.Context) error {
        return c.Render(http.StatusCreated, r.JSON(contentContainer))
    }).Wants("json", func(c buffalo.Context) error {
        return c.Render(http.StatusCreated, r.JSON(contentContainer))
    }).Wants("xml", func(c buffalo.Context) error {
        return c.Render(http.StatusCreated, r.XML(contentContainer))
    }).Respond(c)
}

// Update changes a Content in the DB. This function is mapped to
// the path PUT /contents/{content_id}
func (v ContentsResource) Update(c buffalo.Context) error {
    _, tx, err := managers.ManagerCanCUD(&c)
    if err != nil {
        return err
    }

    // Allocate an empty Content
    contentContainer := &models.Content{}
    if err := tx.Find(contentContainer, c.Param("content_id")); err != nil {
        return c.Error(http.StatusNotFound, err)
    }

    // Bind Content to the html form elements (Nuke this)
    if err := c.Bind(contentContainer); err != nil {
        return err
    }
    verrs, err := tx.ValidateAndUpdate(contentContainer)
    if err != nil {
        return err
    }

    if verrs.HasAny() {
        return responder.Wants("html", func(c buffalo.Context) error {
            return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
        }).Wants("json", func(c buffalo.Context) error {
            return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
        }).Wants("xml", func(c buffalo.Context) error {
            return c.Render(http.StatusUnprocessableEntity, r.XML(verrs))
        }).Respond(c)
    }

    return responder.Wants("html", func(c buffalo.Context) error {
        return c.Render(http.StatusOK, r.JSON(contentContainer))
    }).Wants("json", func(c buffalo.Context) error {
        return c.Render(http.StatusOK, r.JSON(contentContainer))
    }).Wants("xml", func(c buffalo.Context) error {
        return c.Render(http.StatusOK, r.XML(contentContainer))
    }).Respond(c)
}

// Destroy deletes a Content from the DB. This function is mapped
// to the path DELETE /contents/{content_id}
func (v ContentsResource) Destroy(c buffalo.Context) error {
    _, tx, err := managers.ManagerCanCUD(&c)
    if err != nil {
        return err
    }

    // TODO: Manager should probably be the thing doing updates etc.
    // Allocate an empty Content
    contentContainer := &models.Content{}

    // To find the Content the parameter content_id is used.
    if err := tx.Find(contentContainer, c.Param("content_id")); err != nil {
        return c.Error(http.StatusNotFound, err)
    }
    if err := tx.Destroy(contentContainer); err != nil {
        return err
    }

    return responder.Wants("html", func(c buffalo.Context) error {
        return c.Render(http.StatusOK, r.JSON(contentContainer))
    }).Wants("json", func(c buffalo.Context) error {
        return c.Render(http.StatusOK, r.JSON(contentContainer))
    }).Wants("xml", func(c buffalo.Context) error {
        return c.Render(http.StatusOK, r.XML(contentContainer))
    }).Respond(c)
}
