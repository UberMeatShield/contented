package actions

import (
	"log"
	"net/http"

	// "errors"
	// "fmt"
	"contented/managers"
	"contented/models"

	"github.com/gobuffalo/buffalo"
	"github.com/gofrs/uuid"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Content)
// DB Table: Plural (contents)
// Resource: Plural (Contents)
// Path: Plural (/contents)
// View Template Folder: Plural (/templates/contents/)

// ContentsResource is the resource for the Content model
type ContentsResource struct {
	buffalo.Resource
}

// List gets all Contents. This function is mapped to the path
// GET /contents
func (v ContentsResource) List(c buffalo.Context) error {
	// Get the DB connection from the context

	man := managers.GetManager(&c)
	var contentContainers *models.Contents

	// Optional params suuuuck in GoLang
	cID_str := c.Param("container_id")
	if cID_str != "" {
		log.Printf("Attempting to get content using %s", cID_str)
		cID, err := uuid.FromString(cID_str)
		if err != nil {
			return c.Error(http.StatusBadRequest, err)
		}
		mcs, q_err := man.ListContentContext(cID)
		if q_err != nil {
			return c.Error(http.StatusBadRequest, err)
		}
		contentContainers = mcs
	} else {
		log.Printf("List all Content No Restriction on the container ID")
		// TODO: Fix the lack of page support and TEST IT
		_, per_page, page := managers.GetPagination(c.Params(), man.GetCfg().Limit)
		mcs, err := man.ListAllContent(page, per_page)
		if err != nil {
			return c.Error(http.StatusBadRequest, err)
		}
		contentContainers = mcs
	}
	return c.Render(200, r.JSON(contentContainers))
}

// Show gets the data for one Content. This function is mapped to
// the path GET /contents/{content_id}
func (v ContentsResource) Show(c buffalo.Context) error {
	man := managers.GetManager(&c)

	// TODO: Make it actually just handle /content (page, number)
	uuid, err := uuid.FromString(c.Param("content_id"))
	if err != nil {
		return c.Error(http.StatusBadRequest, err)
	}

	contentContainer, missing_err := man.GetContent(uuid)
	if missing_err != nil {
		return c.Error(http.StatusNotFound, missing_err)
	}
	return c.Render(200, r.JSON(contentContainer))
}

// Create adds a Content to the DB. This function is mapped to the
// path POST /contents
func (v ContentsResource) Create(c buffalo.Context) error {
	_, _, err := managers.ManagerCanCUD(&c)
	// Allocate an empty Content
	// Bind contentContainer to the html form elements (probably not required?)
	content := &models.Content{}
	if err := c.Bind(content); err != nil {
		return err
	}
	man := managers.GetManager(&c)
	err = man.CreateContent(content)
	if err != nil {
		return c.Render(http.StatusBadRequest, r.JSON(err))
	}
	validate, checkErr := man.GetContent(content.ID)
	if checkErr != nil {
		return c.Render(http.StatusExpectationFailed, r.JSON(checkErr))
	}
	return c.Render(http.StatusCreated, r.JSON(validate))
}

// Update changes a Content in the DB. This function is mapped to
// the path PUT /contents/{content_id}
func (v ContentsResource) Update(c buffalo.Context) error {
	_, _, err := managers.ManagerCanCUD(&c)
	if err != nil {
		return err
	}

	man := managers.GetManager(&c)
	id, _ := uuid.FromString(c.Param("content_id"))
	exists, err := man.GetContent(id)
	if err != nil || exists == nil {
		return c.Error(http.StatusNotFound, err)
	}
	// Bind Content to the html form elements (Nuke this? or change to json)
	content := *exists
	if err := c.Bind(&content); err != nil {
		return err
	}
	upErr := man.UpdateContent(&content)
	if upErr != nil {
		log.Printf("Failed to update resource %s", upErr)
		return upErr
	}
	checkContent, checkErr := man.GetContent(content.ID)
	if checkErr != nil {
		return c.Render(http.StatusExpectationFailed, r.JSON(checkErr))
	}
	return c.Render(http.StatusOK, r.JSON(checkContent))
}

// Destroy deletes a Content from the DB. This function is mapped
// to the path DELETE /contents/{content_id}
func (v ContentsResource) Destroy(c buffalo.Context) error {
	_, _, err := managers.ManagerCanCUD(&c)
	if err != nil {
		return err
	}
	// TODO: Manager should ABSOLUTELY be the thing doing updates etc.
	// Allocate an empty Content
	contentContainer := &models.Content{}

	id := c.Param("content_id")
	man := managers.GetManager(&c)
	content, err := man.DestroyContent(id)
	if err != nil {
		if content == nil {
			return c.Error(http.StatusNotFound, err)
		} else {
			return c.Error(http.StatusBadRequest, err)
		}
	}
	return c.Render(http.StatusOK, r.JSON(contentContainer))
}
