package actions

import (
	"contented/managers"
	"contented/models"
	"log"
	"strconv"

	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/gobuffalo/buffalo"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Container)
// DB Table: Plural (containers)
// Resource: Plural (Containers)
// Path: Plural (/containers)
// View Template Folder: Plural (/templates/containers/)

type ContainersResponse struct {
	Total   int               `json:"total"`
	Results models.Containers `json:"results"`
}

// ContainersResource is the resource for the Container model
type ContainersResource struct {
	buffalo.Resource
}

// List gets all Containers. This function is mapped to the path
// GET /containers
func ContainersResourceList(c *gin.Context) {
	man := managers.GetManager(c)
	containers, total, err := man.ListContainersContext()
	if err != nil {
		c.AbortWithError(http.StatusBadRequest, err)
		return
	}
	log.Printf("Found %d containers", total)
	cr := ContainersResponse{
		Total:   total,
		Results: *containers,
	}
	c.JSON(200, cr)
}

// Show gets the data for one Container. This function is mapped to
// the path GET /containers/{container_id}
func ContainersResourceShow(c *gin.Context) {
	cID, err := strconv.ParseInt(c.Param("container_id"), 10, 64)
	if err != nil {
		c.AbortWithError(http.StatusBadRequest, err)
		return
	}

	// Get the DB connection from the context
	man := managers.GetManager(c)
	container, err := man.GetContainer(cID)
	if err != nil {
		c.AbortWithError(http.StatusNotFound, err)
		return
	}
	c.JSON(200, container)
}

// Create adds a Container to the DB. This function is mapped to the
// path POST /containers
func ContainersResourceCreate(c *gin.Context) {
	// Allocate an empty Container
	man, _, err := managers.ManagerCanCUD(c)
	if err != nil {
		c.AbortWithError(http.StatusForbidden, err)
		return
	}

	// Bind container to the html form elements
	container := &models.Container{}
	if err := c.Bind(container); err != nil {
		c.AbortWithError(http.StatusBadRequest, err)
	}

	cfg := man.GetCfg()
	// IS-327 Reset the path for now
	container.Path = cfg.Dir

	c_err := man.CreateContainer(container)
	if c_err != nil {
		c.AbortWithError(http.StatusInternalServerError, c_err)
		return
	}
	validate, vErr := man.GetContainer(container.ID)
	if vErr != nil {
		c.AbortWithError(http.StatusInternalServerError, vErr)
		return
	}
	c.JSON(http.StatusCreated, validate)
}

// Update changes a Container in the DB. This function is mapped to
// the path PUT /containers/{container_id}
func ContainersResourceUpdate(c *gin.Context) {
	// Get the DB connection from the context
	man, _, err := managers.ManagerCanCUD(c)
	if err != nil {
		c.AbortWithError(http.StatusNotImplemented, err)
		return
	}

	// Allocate an empty Container
	id, idErr := strconv.ParseInt(c.Param("container_id"), 10, 64)
	if idErr != nil {
		c.AbortWithError(http.StatusBadRequest, idErr)
		return
	}
	// Bind Container to the html form elements (could toss the context into the manager)
	cnt, notFoundErr := man.GetContainer(id)
	if notFoundErr != nil {
		c.AbortWithError(http.StatusNotFound, notFoundErr)
		return
	}
	if err := c.Bind(cnt); err != nil {
		c.AbortWithError(http.StatusBadRequest, err)
		return
	}
	upCnt, upErr := man.UpdateContainer(cnt)
	if upErr != nil {
		c.AbortWithError(http.StatusInternalServerError, upErr)
		return
	}
	c.JSON(http.StatusOK, upCnt)
}

// Destroy deletes a Container from the DB. This function is mapped
// to the path DELETE /containers/{container_id}
func ContainersResourceDestroy(c *gin.Context) {
	// Get the DB connection from the context
	man, _, err := managers.ManagerCanCUD(c)
	if err != nil {
		c.AbortWithError(http.StatusForbidden, err)
	}
	id := c.Param("container_id")
	cnt, dErr := man.DestroyContainer(id)
	if dErr != nil {
		if cnt == nil {
			c.AbortWithError(http.StatusNotFound, dErr)
			return
		} else {
			c.AbortWithError(http.StatusUnprocessableEntity, dErr)
			return
		}
	}
	c.JSON(http.StatusOK, cnt)
}
